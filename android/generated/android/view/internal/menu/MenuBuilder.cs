using Sharpen;

namespace android.view.@internal.menu
{
	/// <summary>
	/// Implementation of the
	/// <see cref="android.view.Menu">android.view.Menu</see>
	/// interface for creating a
	/// standard menu UI.
	/// </summary>
	[Sharpen.Sharpened]
	public class MenuBuilder : android.view.Menu
	{
		internal const string TAG = "MenuBuilder";

		internal const string PRESENTER_KEY = "android:menu:presenters";

		internal const string ACTION_VIEW_STATES_KEY = "android:menu:actionviewstates";

		internal const string EXPANDED_ACTION_VIEW_ID = "android:menu:expandedactionview";

		private static readonly int[] sCategoryToOrder = new int[] { 1, 4, 5, 3, 2, 0 };

		private readonly android.content.Context mContext;

		private readonly android.content.res.Resources mResources;

		/// <summary>Whether the shortcuts should be qwerty-accessible.</summary>
		/// <remarks>
		/// Whether the shortcuts should be qwerty-accessible. Use isQwertyMode()
		/// instead of accessing this directly.
		/// </remarks>
		private bool mQwertyMode;

		/// <summary>Whether the shortcuts should be visible on menus.</summary>
		/// <remarks>
		/// Whether the shortcuts should be visible on menus. Use isShortcutsVisible()
		/// instead of accessing this directly.
		/// </remarks>
		private bool mShortcutsVisible;

		/// <summary>
		/// Callback that will receive the various menu-related events generated by
		/// this class.
		/// </summary>
		/// <remarks>
		/// Callback that will receive the various menu-related events generated by
		/// this class. Use getCallback to get a reference to the callback.
		/// </remarks>
		private android.view.@internal.menu.MenuBuilder.Callback mCallback;

		/// <summary>Contains all of the items for this menu</summary>
		private java.util.ArrayList<android.view.@internal.menu.MenuItemImpl> mItems;

		/// <summary>Contains only the items that are currently visible.</summary>
		/// <remarks>
		/// Contains only the items that are currently visible.  This will be created/refreshed from
		/// <see cref="getVisibleItems()">getVisibleItems()</see>
		/// 
		/// </remarks>
		private java.util.ArrayList<android.view.@internal.menu.MenuItemImpl> mVisibleItems;

		/// <summary>
		/// Whether or not the items (or any one item's shown state) has changed since it was last
		/// fetched from
		/// <see cref="getVisibleItems()">getVisibleItems()</see>
		/// </summary>
		private bool mIsVisibleItemsStale;

		/// <summary>Contains only the items that should appear in the Action Bar, if present.
		/// 	</summary>
		/// <remarks>Contains only the items that should appear in the Action Bar, if present.
		/// 	</remarks>
		private java.util.ArrayList<android.view.@internal.menu.MenuItemImpl> mActionItems;

		/// <summary>Contains items that should NOT appear in the Action Bar, if present.</summary>
		/// <remarks>Contains items that should NOT appear in the Action Bar, if present.</remarks>
		private java.util.ArrayList<android.view.@internal.menu.MenuItemImpl> mNonActionItems;

		/// <summary>
		/// Whether or not the items (or any one item's action state) has changed since it was
		/// last fetched.
		/// </summary>
		/// <remarks>
		/// Whether or not the items (or any one item's action state) has changed since it was
		/// last fetched.
		/// </remarks>
		private bool mIsActionItemsStale;

		/// <summary>Default value for how added items should show in the action list.</summary>
		/// <remarks>Default value for how added items should show in the action list.</remarks>
		private int mDefaultShowAsAction = android.view.MenuItemClass.SHOW_AS_ACTION_NEVER;

		/// <summary>
		/// Current use case is Context Menus: As Views populate the context menu, each one has
		/// extra information that should be passed along.
		/// </summary>
		/// <remarks>
		/// Current use case is Context Menus: As Views populate the context menu, each one has
		/// extra information that should be passed along.  This is the current menu info that
		/// should be set on all items added to this menu.
		/// </remarks>
		private android.view.ContextMenuClass.ContextMenuInfo mCurrentMenuInfo;

		/// <summary>Header title for menu types that have a header (context and submenus)</summary>
		internal java.lang.CharSequence mHeaderTitle;

		/// <summary>Header icon for menu types that have a header and support icons (context)
		/// 	</summary>
		internal android.graphics.drawable.Drawable mHeaderIcon;

		/// <summary>Header custom view for menu types that have a header and support custom views (context)
		/// 	</summary>
		internal android.view.View mHeaderView;

		/// <summary>
		/// Contains the state of the View hierarchy for all menu views when the menu
		/// was frozen.
		/// </summary>
		/// <remarks>
		/// Contains the state of the View hierarchy for all menu views when the menu
		/// was frozen.
		/// </remarks>
		private android.util.SparseArray<android.os.Parcelable> mFrozenViewStates;

		/// <summary>
		/// Prevents onItemsChanged from doing its junk, useful for batching commands
		/// that may individually call onItemsChanged.
		/// </summary>
		/// <remarks>
		/// Prevents onItemsChanged from doing its junk, useful for batching commands
		/// that may individually call onItemsChanged.
		/// </remarks>
		private bool mPreventDispatchingItemsChanged = false;

		private bool mItemsChangedWhileDispatchPrevented = false;

		private bool mOptionalIconsVisible = false;

		private bool mIsClosing = false;

		private java.util.ArrayList<android.view.@internal.menu.MenuItemImpl> mTempShortcutItemList
			 = new java.util.ArrayList<android.view.@internal.menu.MenuItemImpl>();

		private java.util.concurrent.CopyOnWriteArrayList<java.lang.@ref.WeakReference<android.view.@internal.menu.MenuPresenter
			>> mPresenters = new java.util.concurrent.CopyOnWriteArrayList<java.lang.@ref.WeakReference
			<android.view.@internal.menu.MenuPresenter>>();

		/// <summary>Currently expanded menu item; must be collapsed when we clear.</summary>
		/// <remarks>Currently expanded menu item; must be collapsed when we clear.</remarks>
		private android.view.@internal.menu.MenuItemImpl mExpandedItem;

		/// <summary>Called by menu to notify of close and selection changes.</summary>
		/// <remarks>Called by menu to notify of close and selection changes.</remarks>
		public interface Callback
		{
			/// <summary>Called when a menu item is selected.</summary>
			/// <remarks>Called when a menu item is selected.</remarks>
			/// <param name="menu">The menu that is the parent of the item</param>
			/// <param name="item">The menu item that is selected</param>
			/// <returns>whether the menu item selection was handled</returns>
			bool onMenuItemSelected(android.view.@internal.menu.MenuBuilder menu, android.view.MenuItem
				 item);

			/// <summary>Called when the mode of the menu changes (for example, from icon to expanded).
			/// 	</summary>
			/// <remarks>Called when the mode of the menu changes (for example, from icon to expanded).
			/// 	</remarks>
			/// <param name="menu">the menu that has changed modes</param>
			void onMenuModeChange(android.view.@internal.menu.MenuBuilder menu);
		}

		/// <summary>Called by menu items to execute their associated action</summary>
		public interface ItemInvoker
		{
			bool invokeItem(android.view.@internal.menu.MenuItemImpl item);
		}

		public MenuBuilder(android.content.Context context)
		{
			mContext = context;
			mResources = context.getResources();
			mItems = new java.util.ArrayList<android.view.@internal.menu.MenuItemImpl>();
			mVisibleItems = new java.util.ArrayList<android.view.@internal.menu.MenuItemImpl>
				();
			mIsVisibleItemsStale = true;
			mActionItems = new java.util.ArrayList<android.view.@internal.menu.MenuItemImpl>(
				);
			mNonActionItems = new java.util.ArrayList<android.view.@internal.menu.MenuItemImpl
				>();
			mIsActionItemsStale = true;
			setShortcutsVisibleInner(true);
		}

		public virtual android.view.@internal.menu.MenuBuilder setDefaultShowAsAction(int
			 defaultShowAsAction)
		{
			mDefaultShowAsAction = defaultShowAsAction;
			return this;
		}

		/// <summary>Add a presenter to this menu.</summary>
		/// <remarks>
		/// Add a presenter to this menu. This will only hold a WeakReference;
		/// you do not need to explicitly remove a presenter, but you can using
		/// <see cref="removeMenuPresenter(MenuPresenter)">removeMenuPresenter(MenuPresenter)
		/// 	</see>
		/// .
		/// </remarks>
		/// <param name="presenter">The presenter to add</param>
		public virtual void addMenuPresenter(android.view.@internal.menu.MenuPresenter presenter
			)
		{
			mPresenters.add(new java.lang.@ref.WeakReference<android.view.@internal.menu.MenuPresenter
				>(presenter));
			presenter.initForMenu(mContext, this);
			mIsActionItemsStale = true;
		}

		/// <summary>Remove a presenter from this menu.</summary>
		/// <remarks>
		/// Remove a presenter from this menu. That presenter will no longer
		/// receive notifications of updates to this menu's data.
		/// </remarks>
		/// <param name="presenter">The presenter to remove</param>
		public virtual void removeMenuPresenter(android.view.@internal.menu.MenuPresenter
			 presenter)
		{
			foreach (java.lang.@ref.WeakReference<android.view.@internal.menu.MenuPresenter> 
				@ref in Sharpen.IterableProxy.Create(mPresenters))
			{
				android.view.@internal.menu.MenuPresenter item = @ref.get();
				if (item == null || item == presenter)
				{
					mPresenters.remove(@ref);
				}
			}
		}

		private void dispatchPresenterUpdate(bool cleared)
		{
			if (mPresenters.isEmpty())
			{
				return;
			}
			stopDispatchingItemsChanged();
			foreach (java.lang.@ref.WeakReference<android.view.@internal.menu.MenuPresenter> 
				@ref in Sharpen.IterableProxy.Create(mPresenters))
			{
				android.view.@internal.menu.MenuPresenter presenter = @ref.get();
				if (presenter == null)
				{
					mPresenters.remove(@ref);
				}
				else
				{
					presenter.updateMenuView(cleared);
				}
			}
			startDispatchingItemsChanged();
		}

		private bool dispatchSubMenuSelected(android.view.@internal.menu.SubMenuBuilder subMenu
			)
		{
			if (mPresenters.isEmpty())
			{
				return false;
			}
			bool result = false;
			foreach (java.lang.@ref.WeakReference<android.view.@internal.menu.MenuPresenter> 
				@ref in Sharpen.IterableProxy.Create(mPresenters))
			{
				android.view.@internal.menu.MenuPresenter presenter = @ref.get();
				if (presenter == null)
				{
					mPresenters.remove(@ref);
				}
				else
				{
					if (!result)
					{
						result = presenter.onSubMenuSelected(subMenu);
					}
				}
			}
			return result;
		}

		private void dispatchSaveInstanceState(android.os.Bundle outState)
		{
			if (mPresenters.isEmpty())
			{
				return;
			}
			android.util.SparseArray<android.os.Parcelable> presenterStates = new android.util.SparseArray
				<android.os.Parcelable>();
			foreach (java.lang.@ref.WeakReference<android.view.@internal.menu.MenuPresenter> 
				@ref in Sharpen.IterableProxy.Create(mPresenters))
			{
				android.view.@internal.menu.MenuPresenter presenter = @ref.get();
				if (presenter == null)
				{
					mPresenters.remove(@ref);
				}
				else
				{
					int id = presenter.getId();
					if (id > 0)
					{
						android.os.Parcelable state = presenter.onSaveInstanceState();
						if (state != null)
						{
							presenterStates.put(id, state);
						}
					}
				}
			}
			outState.putSparseParcelableArray(PRESENTER_KEY, presenterStates);
		}

		[Sharpen.Stub]
		private void dispatchRestoreInstanceState(android.os.Bundle state)
		{
			throw new System.NotImplementedException();
		}

		public virtual void savePresenterStates(android.os.Bundle outState)
		{
			dispatchSaveInstanceState(outState);
		}

		public virtual void restorePresenterStates(android.os.Bundle state)
		{
			dispatchRestoreInstanceState(state);
		}

		public virtual void saveActionViewStates(android.os.Bundle outStates)
		{
			android.util.SparseArray<android.os.Parcelable> viewStates = null;
			int itemCount = size();
			{
				for (int i = 0; i < itemCount; i++)
				{
					android.view.MenuItem item = getItem(i);
					android.view.View v = item.getActionView();
					if (v != null && v.getId() != android.view.View.NO_ID)
					{
						if (viewStates == null)
						{
							viewStates = new android.util.SparseArray<android.os.Parcelable>();
						}
						v.saveHierarchyState(viewStates);
						if (item.isActionViewExpanded())
						{
							outStates.putInt(EXPANDED_ACTION_VIEW_ID, item.getItemId());
						}
					}
					if (item.hasSubMenu())
					{
						android.view.@internal.menu.SubMenuBuilder subMenu = (android.view.@internal.menu.SubMenuBuilder
							)item.getSubMenu();
						subMenu.saveActionViewStates(outStates);
					}
				}
			}
			if (viewStates != null)
			{
				outStates.putSparseParcelableArray(getActionViewStatesKey(), viewStates);
			}
		}

		[Sharpen.Stub]
		public virtual void restoreActionViewStates(android.os.Bundle states)
		{
			throw new System.NotImplementedException();
		}

		protected internal virtual string getActionViewStatesKey()
		{
			return ACTION_VIEW_STATES_KEY;
		}

		public virtual void setCallback(android.view.@internal.menu.MenuBuilder.Callback 
			cb)
		{
			mCallback = cb;
		}

		/// <summary>Adds an item to the menu.</summary>
		/// <remarks>Adds an item to the menu.  The other add methods funnel to this.</remarks>
		private android.view.MenuItem addInternal(int group, int id, int categoryOrder, java.lang.CharSequence
			 title)
		{
			int ordering = getOrdering(categoryOrder);
			android.view.@internal.menu.MenuItemImpl item = new android.view.@internal.menu.MenuItemImpl
				(this, group, id, categoryOrder, ordering, title, mDefaultShowAsAction);
			if (mCurrentMenuInfo != null)
			{
				// Pass along the current menu info
				item.setMenuInfo(mCurrentMenuInfo);
			}
			mItems.add(findInsertIndex(mItems, ordering), item);
			onItemsChanged(true);
			return item;
		}

		[Sharpen.ImplementsInterface(@"android.view.Menu")]
		public virtual android.view.MenuItem add(java.lang.CharSequence title)
		{
			return addInternal(0, 0, 0, title);
		}

		[Sharpen.ImplementsInterface(@"android.view.Menu")]
		public virtual android.view.MenuItem add(int titleRes)
		{
			return addInternal(0, 0, 0, java.lang.CharSequenceProxy.Wrap(mResources.getString
				(titleRes)));
		}

		[Sharpen.ImplementsInterface(@"android.view.Menu")]
		public virtual android.view.MenuItem add(int group, int id, int categoryOrder, java.lang.CharSequence
			 title)
		{
			return addInternal(group, id, categoryOrder, title);
		}

		[Sharpen.ImplementsInterface(@"android.view.Menu")]
		public virtual android.view.MenuItem add(int group, int id, int categoryOrder, int
			 title)
		{
			return addInternal(group, id, categoryOrder, java.lang.CharSequenceProxy.Wrap(mResources
				.getString(title)));
		}

		[Sharpen.ImplementsInterface(@"android.view.Menu")]
		public virtual android.view.SubMenu addSubMenu(java.lang.CharSequence title)
		{
			return addSubMenu(0, 0, 0, title);
		}

		[Sharpen.ImplementsInterface(@"android.view.Menu")]
		public virtual android.view.SubMenu addSubMenu(int titleRes)
		{
			return addSubMenu(0, 0, 0, java.lang.CharSequenceProxy.Wrap(mResources.getString(
				titleRes)));
		}

		[Sharpen.ImplementsInterface(@"android.view.Menu")]
		public virtual android.view.SubMenu addSubMenu(int group, int id, int categoryOrder
			, java.lang.CharSequence title)
		{
			android.view.@internal.menu.MenuItemImpl item = (android.view.@internal.menu.MenuItemImpl
				)addInternal(group, id, categoryOrder, title);
			android.view.@internal.menu.SubMenuBuilder subMenu = new android.view.@internal.menu.SubMenuBuilder
				(mContext, this, item);
			item.setSubMenu(subMenu);
			return subMenu;
		}

		[Sharpen.ImplementsInterface(@"android.view.Menu")]
		public virtual android.view.SubMenu addSubMenu(int group, int id, int categoryOrder
			, int title)
		{
			return addSubMenu(group, id, categoryOrder, java.lang.CharSequenceProxy.Wrap(mResources
				.getString(title)));
		}

		[Sharpen.ImplementsInterface(@"android.view.Menu")]
		public virtual int addIntentOptions(int group, int id, int categoryOrder, android.content.ComponentName
			 caller, android.content.Intent[] specifics, android.content.Intent intent, int 
			flags, android.view.MenuItem[] outSpecificItems)
		{
			android.content.pm.PackageManager pm = mContext.getPackageManager();
			java.util.List<android.content.pm.ResolveInfo> lri = pm.queryIntentActivityOptions
				(caller, specifics, intent, 0);
			int N = lri != null ? lri.size() : 0;
			if ((flags & android.view.MenuClass.FLAG_APPEND_TO_GROUP) == 0)
			{
				removeGroup(group);
			}
			{
				for (int i = 0; i < N; i++)
				{
					android.content.pm.ResolveInfo ri = lri.get(i);
					android.content.Intent rintent = new android.content.Intent(ri.specificIndex < 0 ? 
						intent : specifics[ri.specificIndex]);
					rintent.setComponent(new android.content.ComponentName(ri.activityInfo.applicationInfo
						.packageName, ri.activityInfo.name));
					android.view.MenuItem item = add(group, id, categoryOrder, ri.loadLabel(pm)).setIcon
						(ri.loadIcon(pm)).setIntent(rintent);
					if (outSpecificItems != null && ri.specificIndex >= 0)
					{
						outSpecificItems[ri.specificIndex] = item;
					}
				}
			}
			return N;
		}

		[Sharpen.ImplementsInterface(@"android.view.Menu")]
		public virtual void removeItem(int id)
		{
			removeItemAtInt(findItemIndex(id), true);
		}

		[Sharpen.ImplementsInterface(@"android.view.Menu")]
		public virtual void removeGroup(int group)
		{
			int i = findGroupIndex(group);
			if (i >= 0)
			{
				int maxRemovable = mItems.size() - i;
				int numRemoved = 0;
				while ((numRemoved++ < maxRemovable) && (mItems.get(i).getGroupId() == group))
				{
					// Don't force update for each one, this method will do it at the end
					removeItemAtInt(i, false);
				}
				// Notify menu views
				onItemsChanged(true);
			}
		}

		/// <summary>
		/// Remove the item at the given index and optionally forces menu views to
		/// update.
		/// </summary>
		/// <remarks>
		/// Remove the item at the given index and optionally forces menu views to
		/// update.
		/// </remarks>
		/// <param name="index">
		/// The index of the item to be removed. If this index is
		/// invalid an exception is thrown.
		/// </param>
		/// <param name="updateChildrenOnMenuViews">
		/// Whether to force update on menu views.
		/// Please make sure you eventually call this after your batch of
		/// removals.
		/// </param>
		private void removeItemAtInt(int index, bool updateChildrenOnMenuViews)
		{
			if ((index < 0) || (index >= mItems.size()))
			{
				return;
			}
			mItems.remove(index);
			if (updateChildrenOnMenuViews)
			{
				onItemsChanged(true);
			}
		}

		public virtual void removeItemAt(int index)
		{
			removeItemAtInt(index, true);
		}

		public virtual void clearAll()
		{
			mPreventDispatchingItemsChanged = true;
			clear();
			clearHeader();
			mPreventDispatchingItemsChanged = false;
			mItemsChangedWhileDispatchPrevented = false;
			onItemsChanged(true);
		}

		[Sharpen.ImplementsInterface(@"android.view.Menu")]
		public virtual void clear()
		{
			if (mExpandedItem != null)
			{
				collapseItemActionView(mExpandedItem);
			}
			mItems.clear();
			onItemsChanged(true);
		}

		internal virtual void setExclusiveItemChecked(android.view.MenuItem item)
		{
			int group = item.getGroupId();
			int N = mItems.size();
			{
				for (int i = 0; i < N; i++)
				{
					android.view.@internal.menu.MenuItemImpl curItem = mItems.get(i);
					if (curItem.getGroupId() == group)
					{
						if (!curItem.isExclusiveCheckable())
						{
							continue;
						}
						if (!curItem.isCheckable())
						{
							continue;
						}
						// Check the item meant to be checked, uncheck the others (that are in the group)
						curItem.setCheckedInt(curItem == item);
					}
				}
			}
		}

		[Sharpen.ImplementsInterface(@"android.view.Menu")]
		public virtual void setGroupCheckable(int group, bool checkable, bool exclusive)
		{
			int N = mItems.size();
			{
				for (int i = 0; i < N; i++)
				{
					android.view.@internal.menu.MenuItemImpl item = mItems.get(i);
					if (item.getGroupId() == group)
					{
						item.setExclusiveCheckable(exclusive);
						item.setCheckable(checkable);
					}
				}
			}
		}

		[Sharpen.ImplementsInterface(@"android.view.Menu")]
		public virtual void setGroupVisible(int group, bool visible)
		{
			int N = mItems.size();
			// We handle the notification of items being changed ourselves, so we use setVisibleInt rather
			// than setVisible and at the end notify of items being changed
			bool changedAtLeastOneItem = false;
			{
				for (int i = 0; i < N; i++)
				{
					android.view.@internal.menu.MenuItemImpl item = mItems.get(i);
					if (item.getGroupId() == group)
					{
						if (item.setVisibleInt(visible))
						{
							changedAtLeastOneItem = true;
						}
					}
				}
			}
			if (changedAtLeastOneItem)
			{
				onItemsChanged(true);
			}
		}

		[Sharpen.ImplementsInterface(@"android.view.Menu")]
		public virtual void setGroupEnabled(int group, bool enabled)
		{
			int N = mItems.size();
			{
				for (int i = 0; i < N; i++)
				{
					android.view.@internal.menu.MenuItemImpl item = mItems.get(i);
					if (item.getGroupId() == group)
					{
						item.setEnabled(enabled);
					}
				}
			}
		}

		[Sharpen.ImplementsInterface(@"android.view.Menu")]
		public virtual bool hasVisibleItems()
		{
			int size_1 = size();
			{
				for (int i = 0; i < size_1; i++)
				{
					android.view.@internal.menu.MenuItemImpl item = mItems.get(i);
					if (item.isVisible())
					{
						return true;
					}
				}
			}
			return false;
		}

		[Sharpen.ImplementsInterface(@"android.view.Menu")]
		public virtual android.view.MenuItem findItem(int id)
		{
			int size_1 = size();
			{
				for (int i = 0; i < size_1; i++)
				{
					android.view.@internal.menu.MenuItemImpl item = mItems.get(i);
					if (item.getItemId() == id)
					{
						return item;
					}
					else
					{
						if (item.hasSubMenu())
						{
							android.view.MenuItem possibleItem = item.getSubMenu().findItem(id);
							if (possibleItem != null)
							{
								return possibleItem;
							}
						}
					}
				}
			}
			return null;
		}

		public virtual int findItemIndex(int id)
		{
			int size_1 = size();
			{
				for (int i = 0; i < size_1; i++)
				{
					android.view.@internal.menu.MenuItemImpl item = mItems.get(i);
					if (item.getItemId() == id)
					{
						return i;
					}
				}
			}
			return -1;
		}

		public virtual int findGroupIndex(int group)
		{
			return findGroupIndex(group, 0);
		}

		public virtual int findGroupIndex(int group, int start)
		{
			int size_1 = size();
			if (start < 0)
			{
				start = 0;
			}
			{
				for (int i = start; i < size_1; i++)
				{
					android.view.@internal.menu.MenuItemImpl item = mItems.get(i);
					if (item.getGroupId() == group)
					{
						return i;
					}
				}
			}
			return -1;
		}

		[Sharpen.ImplementsInterface(@"android.view.Menu")]
		public virtual int size()
		{
			return mItems.size();
		}

		/// <summary>
		/// <inheritDoc></inheritDoc>
		/// 
		/// </summary>
		[Sharpen.ImplementsInterface(@"android.view.Menu")]
		public virtual android.view.MenuItem getItem(int index)
		{
			return mItems.get(index);
		}

		[Sharpen.ImplementsInterface(@"android.view.Menu")]
		public virtual bool isShortcutKey(int keyCode, android.view.KeyEvent @event)
		{
			return findItemWithShortcutForKey(keyCode, @event) != null;
		}

		[Sharpen.ImplementsInterface(@"android.view.Menu")]
		public virtual void setQwertyMode(bool isQwerty)
		{
			mQwertyMode = isQwerty;
			onItemsChanged(false);
		}

		/// <summary>Returns the ordering across all items.</summary>
		/// <remarks>
		/// Returns the ordering across all items. This will grab the category from
		/// the upper bits, find out how to order the category with respect to other
		/// categories, and combine it with the lower bits.
		/// </remarks>
		/// <param name="categoryOrder">
		/// The category order for a particular item (if it has
		/// not been or/add with a category, the default category is
		/// assumed).
		/// </param>
		/// <returns>
		/// An ordering integer that can be used to order this item across
		/// all the items (even from other categories).
		/// </returns>
		private static int getOrdering(int categoryOrder)
		{
			int index = (categoryOrder & android.view.MenuClass.CATEGORY_MASK) >> android.view.MenuClass.CATEGORY_SHIFT;
			if (index < 0 || index >= sCategoryToOrder.Length)
			{
				throw new System.ArgumentException("order does not contain a valid category.");
			}
			return (sCategoryToOrder[index] << android.view.MenuClass.CATEGORY_SHIFT) | (categoryOrder
				 & android.view.MenuClass.USER_MASK);
		}

		/// <returns>whether the menu shortcuts are in qwerty mode or not</returns>
		internal virtual bool isQwertyMode()
		{
			return mQwertyMode;
		}

		/// <summary>Sets whether the shortcuts should be visible on menus.</summary>
		/// <remarks>
		/// Sets whether the shortcuts should be visible on menus.  Devices without hardware
		/// key input will never make shortcuts visible even if this method is passed 'true'.
		/// </remarks>
		/// <param name="shortcutsVisible">
		/// Whether shortcuts should be visible (if true and a
		/// menu item does not have a shortcut defined, that item will
		/// still NOT show a shortcut)
		/// </param>
		public virtual void setShortcutsVisible(bool shortcutsVisible)
		{
			if (mShortcutsVisible == shortcutsVisible)
			{
				return;
			}
			setShortcutsVisibleInner(shortcutsVisible);
			onItemsChanged(false);
		}

		private void setShortcutsVisibleInner(bool shortcutsVisible)
		{
			mShortcutsVisible = shortcutsVisible && mResources.getConfiguration().keyboard !=
				 android.content.res.Configuration.KEYBOARD_NOKEYS && mResources.getBoolean(android.@internal.R
				.@bool.config_showMenuShortcutsWhenKeyboardPresent);
		}

		/// <returns>Whether shortcuts should be visible on menus.</returns>
		public virtual bool isShortcutsVisible()
		{
			return mShortcutsVisible;
		}

		internal virtual android.content.res.Resources getResources()
		{
			return mResources;
		}

		public virtual android.content.Context getContext()
		{
			return mContext;
		}

		internal virtual bool dispatchMenuItemSelected(android.view.@internal.menu.MenuBuilder
			 menu, android.view.MenuItem item)
		{
			return mCallback != null && mCallback.onMenuItemSelected(menu, item);
		}

		/// <summary>Dispatch a mode change event to this menu's callback.</summary>
		/// <remarks>Dispatch a mode change event to this menu's callback.</remarks>
		public virtual void changeMenuMode()
		{
			if (mCallback != null)
			{
				mCallback.onMenuModeChange(this);
			}
		}

		private static int findInsertIndex(java.util.ArrayList<android.view.@internal.menu.MenuItemImpl
			> items, int ordering)
		{
			{
				for (int i = items.size() - 1; i >= 0; i--)
				{
					android.view.@internal.menu.MenuItemImpl item = items.get(i);
					if (item.getOrdering() <= ordering)
					{
						return i + 1;
					}
				}
			}
			return 0;
		}

		[Sharpen.ImplementsInterface(@"android.view.Menu")]
		public virtual bool performShortcut(int keyCode, android.view.KeyEvent @event, int
			 flags)
		{
			android.view.@internal.menu.MenuItemImpl item = findItemWithShortcutForKey(keyCode
				, @event);
			bool handled = false;
			if (item != null)
			{
				handled = performItemAction(item, flags);
			}
			if ((flags & android.view.MenuClass.FLAG_ALWAYS_PERFORM_CLOSE) != 0)
			{
				close(true);
			}
			return handled;
		}

		internal virtual void findItemsWithShortcutForKey(java.util.List<android.view.@internal.menu.MenuItemImpl
			> items, int keyCode, android.view.KeyEvent @event)
		{
			bool qwerty = isQwertyMode();
			int metaState = @event.getMetaState();
			android.view.KeyCharacterMap.KeyData possibleChars = new android.view.KeyCharacterMap
				.KeyData();
			// Get the chars associated with the keyCode (i.e using any chording combo)
			bool isKeyCodeMapped = @event.getKeyData(possibleChars);
			// The delete key is not mapped to '\b' so we treat it specially
			if (!isKeyCodeMapped && (keyCode != android.view.KeyEvent.KEYCODE_DEL))
			{
				return;
			}
			// Look for an item whose shortcut is this key.
			int N = mItems.size();
			{
				for (int i = 0; i < N; i++)
				{
					android.view.@internal.menu.MenuItemImpl item = mItems.get(i);
					if (item.hasSubMenu())
					{
						((android.view.@internal.menu.MenuBuilder)item.getSubMenu()).findItemsWithShortcutForKey
							(items, keyCode, @event);
					}
					char shortcutChar = qwerty ? item.getAlphabeticShortcut() : item.getNumericShortcut
						();
					if (((metaState & (android.view.KeyEvent.META_SHIFT_ON | android.view.KeyEvent.META_SYM_ON
						)) == 0) && (shortcutChar != 0) && (shortcutChar == possibleChars.meta[0] || shortcutChar
						 == possibleChars.meta[2] || (qwerty && shortcutChar == '\b' && keyCode == android.view.KeyEvent
						.KEYCODE_DEL)) && item.isEnabled())
					{
						items.add(item);
					}
				}
			}
		}

		internal virtual android.view.@internal.menu.MenuItemImpl findItemWithShortcutForKey
			(int keyCode, android.view.KeyEvent @event)
		{
			// Get all items that can be associated directly or indirectly with the keyCode
			java.util.ArrayList<android.view.@internal.menu.MenuItemImpl> items = mTempShortcutItemList;
			items.clear();
			findItemsWithShortcutForKey(items, keyCode, @event);
			if (items.isEmpty())
			{
				return null;
			}
			int metaState = @event.getMetaState();
			android.view.KeyCharacterMap.KeyData possibleChars = new android.view.KeyCharacterMap
				.KeyData();
			// Get the chars associated with the keyCode (i.e using any chording combo)
			@event.getKeyData(possibleChars);
			// If we have only one element, we can safely returns it
			int size_1 = items.size();
			if (size_1 == 1)
			{
				return items.get(0);
			}
			bool qwerty = isQwertyMode();
			{
				// If we found more than one item associated with the key,
				// we have to return the exact match
				for (int i = 0; i < size_1; i++)
				{
					android.view.@internal.menu.MenuItemImpl item = items.get(i);
					char shortcutChar = qwerty ? item.getAlphabeticShortcut() : item.getNumericShortcut
						();
					if ((shortcutChar == possibleChars.meta[0] && (metaState & android.view.KeyEvent.
						META_ALT_ON) == 0) || (shortcutChar == possibleChars.meta[2] && (metaState & android.view.KeyEvent
						.META_ALT_ON) != 0) || (qwerty && shortcutChar == '\b' && keyCode == android.view.KeyEvent
						.KEYCODE_DEL))
					{
						return item;
					}
				}
			}
			return null;
		}

		[Sharpen.ImplementsInterface(@"android.view.Menu")]
		public virtual bool performIdentifierAction(int id, int flags)
		{
			// Look for an item whose identifier is the id.
			return performItemAction(findItem(id), flags);
		}

		public virtual bool performItemAction(android.view.MenuItem item, int flags)
		{
			android.view.@internal.menu.MenuItemImpl itemImpl = (android.view.@internal.menu.MenuItemImpl
				)item;
			if (itemImpl == null || !itemImpl.isEnabled())
			{
				return false;
			}
			bool invoked = itemImpl.invoke();
			if (itemImpl.hasCollapsibleActionView())
			{
				invoked |= itemImpl.expandActionView();
				if (invoked)
				{
					close(true);
				}
			}
			else
			{
				if (item.hasSubMenu())
				{
					close(false);
					android.view.@internal.menu.SubMenuBuilder subMenu = (android.view.@internal.menu.SubMenuBuilder
						)item.getSubMenu();
					android.view.ActionProvider provider = item.getActionProvider();
					if (provider != null && provider.hasSubMenu())
					{
						provider.onPrepareSubMenu(subMenu);
					}
					invoked |= dispatchSubMenuSelected(subMenu);
					if (!invoked)
					{
						close(true);
					}
				}
				else
				{
					if ((flags & android.view.MenuClass.FLAG_PERFORM_NO_CLOSE) == 0)
					{
						close(true);
					}
				}
			}
			return invoked;
		}

		/// <summary>Closes the visible menu.</summary>
		/// <remarks>Closes the visible menu.</remarks>
		/// <param name="allMenusAreClosing">
		/// Whether the menus are completely closing (true),
		/// or whether there is another menu coming in this menu's place
		/// (false). For example, if the menu is closing because a
		/// sub menu is about to be shown, <var>allMenusAreClosing</var>
		/// is false.
		/// </param>
		internal void close(bool allMenusAreClosing)
		{
			if (mIsClosing)
			{
				return;
			}
			mIsClosing = true;
			foreach (java.lang.@ref.WeakReference<android.view.@internal.menu.MenuPresenter> 
				@ref in Sharpen.IterableProxy.Create(mPresenters))
			{
				android.view.@internal.menu.MenuPresenter presenter = @ref.get();
				if (presenter == null)
				{
					mPresenters.remove(@ref);
				}
				else
				{
					presenter.onCloseMenu(this, allMenusAreClosing);
				}
			}
			mIsClosing = false;
		}

		/// <summary>
		/// <inheritDoc></inheritDoc>
		/// 
		/// </summary>
		[Sharpen.ImplementsInterface(@"android.view.Menu")]
		public virtual void close()
		{
			close(true);
		}

		/// <summary>Called when an item is added or removed.</summary>
		/// <remarks>Called when an item is added or removed.</remarks>
		/// <param name="structureChanged">
		/// true if the menu structure changed,
		/// false if only item properties changed.
		/// (Visibility is a structural property since it affects layout.)
		/// </param>
		internal virtual void onItemsChanged(bool structureChanged)
		{
			if (!mPreventDispatchingItemsChanged)
			{
				if (structureChanged)
				{
					mIsVisibleItemsStale = true;
					mIsActionItemsStale = true;
				}
				dispatchPresenterUpdate(structureChanged);
			}
			else
			{
				mItemsChangedWhileDispatchPrevented = true;
			}
		}

		/// <summary>
		/// Stop dispatching item changed events to presenters until
		/// <see cref="startDispatchingItemsChanged()">startDispatchingItemsChanged()</see>
		/// is called. Useful when
		/// many menu operations are going to be performed as a batch.
		/// </summary>
		public virtual void stopDispatchingItemsChanged()
		{
			if (!mPreventDispatchingItemsChanged)
			{
				mPreventDispatchingItemsChanged = true;
				mItemsChangedWhileDispatchPrevented = false;
			}
		}

		public virtual void startDispatchingItemsChanged()
		{
			mPreventDispatchingItemsChanged = false;
			if (mItemsChangedWhileDispatchPrevented)
			{
				mItemsChangedWhileDispatchPrevented = false;
				onItemsChanged(true);
			}
		}

		/// <summary>
		/// Called by
		/// <see cref="MenuItemImpl">MenuItemImpl</see>
		/// when its visible flag is changed.
		/// </summary>
		/// <param name="item">The item that has gone through a visibility change.</param>
		internal virtual void onItemVisibleChanged(android.view.@internal.menu.MenuItemImpl
			 item)
		{
			// Notify of items being changed
			mIsVisibleItemsStale = true;
			onItemsChanged(true);
		}

		/// <summary>
		/// Called by
		/// <see cref="MenuItemImpl">MenuItemImpl</see>
		/// when its action request status is changed.
		/// </summary>
		/// <param name="item">The item that has gone through a change in action request status.
		/// 	</param>
		internal virtual void onItemActionRequestChanged(android.view.@internal.menu.MenuItemImpl
			 item)
		{
			// Notify of items being changed
			mIsActionItemsStale = true;
			onItemsChanged(true);
		}

		internal virtual java.util.ArrayList<android.view.@internal.menu.MenuItemImpl> getVisibleItems
			()
		{
			if (!mIsVisibleItemsStale)
			{
				return mVisibleItems;
			}
			// Refresh the visible items
			mVisibleItems.clear();
			int itemsSize = mItems.size();
			android.view.@internal.menu.MenuItemImpl item;
			{
				for (int i = 0; i < itemsSize; i++)
				{
					item = mItems.get(i);
					if (item.isVisible())
					{
						mVisibleItems.add(item);
					}
				}
			}
			mIsVisibleItemsStale = false;
			mIsActionItemsStale = true;
			return mVisibleItems;
		}

		/// <summary>
		/// This method determines which menu items get to be 'action items' that will appear
		/// in an action bar and which items should be 'overflow items' in a secondary menu.
		/// </summary>
		/// <remarks>
		/// This method determines which menu items get to be 'action items' that will appear
		/// in an action bar and which items should be 'overflow items' in a secondary menu.
		/// The rules are as follows:
		/// <p>Items are considered for inclusion in the order specified within the menu.
		/// There is a limit of mMaxActionItems as a total count, optionally including the overflow
		/// menu button itself. This is a soft limit; if an item shares a group ID with an item
		/// previously included as an action item, the new item will stay with its group and become
		/// an action item itself even if it breaks the max item count limit. This is done to
		/// limit the conceptual complexity of the items presented within an action bar. Only a few
		/// unrelated concepts should be presented to the user in this space, and groups are treated
		/// as a single concept.
		/// <p>There is also a hard limit of consumed measurable space: mActionWidthLimit. This
		/// limit may be broken by a single item that exceeds the remaining space, but no further
		/// items may be added. If an item that is part of a group cannot fit within the remaining
		/// measured width, the entire group will be demoted to overflow. This is done to ensure room
		/// for navigation and other affordances in the action bar as well as reduce general UI clutter.
		/// <p>The space freed by demoting a full group cannot be consumed by future menu items.
		/// Once items begin to overflow, all future items become overflow items as well. This is
		/// to avoid inadvertent reordering that may break the app's intended design.
		/// </remarks>
		public virtual void flagActionItems()
		{
			if (!mIsActionItemsStale)
			{
				return;
			}
			// Presenters flag action items as needed.
			bool flagged = false;
			foreach (java.lang.@ref.WeakReference<android.view.@internal.menu.MenuPresenter> 
				@ref in Sharpen.IterableProxy.Create(mPresenters))
			{
				android.view.@internal.menu.MenuPresenter presenter = @ref.get();
				if (presenter == null)
				{
					mPresenters.remove(@ref);
				}
				else
				{
					flagged |= presenter.flagActionItems();
				}
			}
			if (flagged)
			{
				mActionItems.clear();
				mNonActionItems.clear();
				java.util.ArrayList<android.view.@internal.menu.MenuItemImpl> visibleItems = getVisibleItems
					();
				int itemsSize = visibleItems.size();
				{
					for (int i = 0; i < itemsSize; i++)
					{
						android.view.@internal.menu.MenuItemImpl item = visibleItems.get(i);
						if (item.isActionButton())
						{
							mActionItems.add(item);
						}
						else
						{
							mNonActionItems.add(item);
						}
					}
				}
			}
			else
			{
				// Nobody flagged anything, everything is a non-action item.
				// (This happens during a first pass with no action-item presenters.)
				mActionItems.clear();
				mNonActionItems.clear();
				mNonActionItems.addAll(getVisibleItems());
			}
			mIsActionItemsStale = false;
		}

		internal virtual java.util.ArrayList<android.view.@internal.menu.MenuItemImpl> getActionItems
			()
		{
			flagActionItems();
			return mActionItems;
		}

		internal virtual java.util.ArrayList<android.view.@internal.menu.MenuItemImpl> getNonActionItems
			()
		{
			flagActionItems();
			return mNonActionItems;
		}

		public virtual void clearHeader()
		{
			mHeaderIcon = null;
			mHeaderTitle = null;
			mHeaderView = null;
			onItemsChanged(false);
		}

		private void setHeaderInternal(int titleRes, java.lang.CharSequence title, int iconRes
			, android.graphics.drawable.Drawable icon, android.view.View view)
		{
			android.content.res.Resources r = getResources();
			if (view != null)
			{
				mHeaderView = view;
				// If using a custom view, then the title and icon aren't used
				mHeaderTitle = null;
				mHeaderIcon = null;
			}
			else
			{
				if (titleRes > 0)
				{
					mHeaderTitle = r.getText(titleRes);
				}
				else
				{
					if (title != null)
					{
						mHeaderTitle = title;
					}
				}
				if (iconRes > 0)
				{
					mHeaderIcon = r.getDrawable(iconRes);
				}
				else
				{
					if (icon != null)
					{
						mHeaderIcon = icon;
					}
				}
				// If using the title or icon, then a custom view isn't used
				mHeaderView = null;
			}
			// Notify of change
			onItemsChanged(false);
		}

		/// <summary>Sets the header's title.</summary>
		/// <remarks>
		/// Sets the header's title. This replaces the header view. Called by the
		/// builder-style methods of subclasses.
		/// </remarks>
		/// <param name="title">The new title.</param>
		/// <returns>This MenuBuilder so additional setters can be called.</returns>
		protected internal virtual android.view.@internal.menu.MenuBuilder setHeaderTitleInt
			(java.lang.CharSequence title)
		{
			setHeaderInternal(0, title, 0, null, null);
			return this;
		}

		/// <summary>Sets the header's title.</summary>
		/// <remarks>
		/// Sets the header's title. This replaces the header view. Called by the
		/// builder-style methods of subclasses.
		/// </remarks>
		/// <param name="titleRes">The new title (as a resource ID).</param>
		/// <returns>This MenuBuilder so additional setters can be called.</returns>
		protected internal virtual android.view.@internal.menu.MenuBuilder setHeaderTitleInt
			(int titleRes)
		{
			setHeaderInternal(titleRes, null, 0, null, null);
			return this;
		}

		/// <summary>Sets the header's icon.</summary>
		/// <remarks>
		/// Sets the header's icon. This replaces the header view. Called by the
		/// builder-style methods of subclasses.
		/// </remarks>
		/// <param name="icon">The new icon.</param>
		/// <returns>This MenuBuilder so additional setters can be called.</returns>
		protected internal virtual android.view.@internal.menu.MenuBuilder setHeaderIconInt
			(android.graphics.drawable.Drawable icon)
		{
			setHeaderInternal(0, null, 0, icon, null);
			return this;
		}

		/// <summary>Sets the header's icon.</summary>
		/// <remarks>
		/// Sets the header's icon. This replaces the header view. Called by the
		/// builder-style methods of subclasses.
		/// </remarks>
		/// <param name="iconRes">The new icon (as a resource ID).</param>
		/// <returns>This MenuBuilder so additional setters can be called.</returns>
		protected internal virtual android.view.@internal.menu.MenuBuilder setHeaderIconInt
			(int iconRes)
		{
			setHeaderInternal(0, null, iconRes, null, null);
			return this;
		}

		/// <summary>Sets the header's view.</summary>
		/// <remarks>
		/// Sets the header's view. This replaces the title and icon. Called by the
		/// builder-style methods of subclasses.
		/// </remarks>
		/// <param name="view">The new view.</param>
		/// <returns>This MenuBuilder so additional setters can be called.</returns>
		protected internal virtual android.view.@internal.menu.MenuBuilder setHeaderViewInt
			(android.view.View view)
		{
			setHeaderInternal(0, null, 0, null, view);
			return this;
		}

		public virtual java.lang.CharSequence getHeaderTitle()
		{
			return mHeaderTitle;
		}

		public virtual android.graphics.drawable.Drawable getHeaderIcon()
		{
			return mHeaderIcon;
		}

		public virtual android.view.View getHeaderView()
		{
			return mHeaderView;
		}

		/// <summary>Gets the root menu (if this is a submenu, find its root menu).</summary>
		/// <remarks>Gets the root menu (if this is a submenu, find its root menu).</remarks>
		/// <returns>The root menu.</returns>
		public virtual android.view.@internal.menu.MenuBuilder getRootMenu()
		{
			return this;
		}

		/// <summary>
		/// Sets the current menu info that is set on all items added to this menu
		/// (until this is called again with different menu info, in which case that
		/// one will be added to all subsequent item additions).
		/// </summary>
		/// <remarks>
		/// Sets the current menu info that is set on all items added to this menu
		/// (until this is called again with different menu info, in which case that
		/// one will be added to all subsequent item additions).
		/// </remarks>
		/// <param name="menuInfo">The extra menu information to add.</param>
		public virtual void setCurrentMenuInfo(android.view.ContextMenuClass.ContextMenuInfo
			 menuInfo)
		{
			mCurrentMenuInfo = menuInfo;
		}

		internal virtual void setOptionalIconsVisible(bool visible)
		{
			mOptionalIconsVisible = visible;
		}

		internal virtual bool getOptionalIconsVisible()
		{
			return mOptionalIconsVisible;
		}

		public virtual bool expandItemActionView(android.view.@internal.menu.MenuItemImpl
			 item)
		{
			if (mPresenters.isEmpty())
			{
				return false;
			}
			bool expanded = false;
			stopDispatchingItemsChanged();
			foreach (java.lang.@ref.WeakReference<android.view.@internal.menu.MenuPresenter> 
				@ref in Sharpen.IterableProxy.Create(mPresenters))
			{
				android.view.@internal.menu.MenuPresenter presenter = @ref.get();
				if (presenter == null)
				{
					mPresenters.remove(@ref);
				}
				else
				{
					if ((expanded = presenter.expandItemActionView(this, item)))
					{
						break;
					}
				}
			}
			startDispatchingItemsChanged();
			if (expanded)
			{
				mExpandedItem = item;
			}
			return expanded;
		}

		public virtual bool collapseItemActionView(android.view.@internal.menu.MenuItemImpl
			 item)
		{
			if (mPresenters.isEmpty() || mExpandedItem != item)
			{
				return false;
			}
			bool collapsed = false;
			stopDispatchingItemsChanged();
			foreach (java.lang.@ref.WeakReference<android.view.@internal.menu.MenuPresenter> 
				@ref in Sharpen.IterableProxy.Create(mPresenters))
			{
				android.view.@internal.menu.MenuPresenter presenter = @ref.get();
				if (presenter == null)
				{
					mPresenters.remove(@ref);
				}
				else
				{
					if ((collapsed = presenter.collapseItemActionView(this, item)))
					{
						break;
					}
				}
			}
			startDispatchingItemsChanged();
			if (collapsed)
			{
				mExpandedItem = null;
			}
			return collapsed;
		}

		public virtual android.view.@internal.menu.MenuItemImpl getExpandedItem()
		{
			return mExpandedItem;
		}
	}
}
